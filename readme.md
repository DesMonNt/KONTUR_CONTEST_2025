# Декодировщик

> Более подробно в ```pipeline.ipynb```
> 
## Предобработка данных

Сигналы Морзе — это последовательности коротких и длинных звуков, которые закодированы на фиксированной или почти фиксированной частоте. Разумно подойти к обработке данных как в ASR.

Я перевел аудио в спектрограммы,  нашел основную частоту морзянки по энергии, после чего отрезал большинство бинов (сигнал узкополосный так что так поступать вполне резонно), оставив только наиболее близкие к частоте Морзе. Потом с помощью порогового фильтра отсек наиболее слабые компоненты. В конце данные просто нормируются по амплитуде.

## Подготовка датасета

Выборка была разбита на обучающую и валидационную в (85 на 15), чтобы в будущем проверять качество модели.

Чтобы не упереться в CPU, я заранее предобработал .opus файлы и сохранил в .pt в формате описанном выше. Из особенностей отмечу перевод целевых меток из кириллицы в алфавит Морзе (т.е. точка-тире). Это даст большую гибкость при использовании в будущем.

## Dataset и Dataloader

Для работы с CTC-loss данные пришлось западдить по оси времени и перевести в последовательность токенов.

Также для увеличения разнообразия и потенциального улучшения стабильности была сделана не очень агрессивная аугментация данных: были добавлены частотные и временные маски и случайный шум.

## Архитектура модели

В качестве ядра модели было принято решение использовать Conformer. Решение обосновано как общей эффективностью трансформеров (conformer так вообще SOTA в ASR), так и минусами вариантов, опирающихся на рекуррентные сети. 

Я пробовал обучать biLSTM и GRU, но при одинаковых вложениях в параметры conformer был в среднем лучше. А также conformer в отличие от ранее упомянутых вариантов можно параллельно просчитывать, эффективно используя ресурсы GPU.

## Обучение

Функционал потерь - ```Connetional temporal classification```. Выбор обоснован хорошей корреляцией с целевой метрикой соревнования и естественно тем, что само по себе расстояние Левенштейна не дифференцируемо и не позволяет проводить обучение градиентными методами.

В самом обучении используется:

- AdamW оптимизатор с встроенной регуляризацией weight-decay (универсальный оптимизатор с хорошей регуляризацией)
- Learning rate warm-up (страхует от взрывов градиентов, своейственных трансформерам на ранних этапах обучения)
- Early stopping (оптимизирует вычислительные ресурсы и дополнительная регуляризация)
- KFold кросс-валидация (позволяет убедиться в стабильности модели)

Готовая модель показывает отличные результаты на валидационной метрике, но сильно проседает на чистых (не аугментированных) тренировочных данных. Так что было принято дообучить модель в течение пары эпох на низком learning rate, чтобы сделать domain adaptation под изначальную задачу. Ранее упомянутые приемы также использовались при дообучении.

## Инференс

Для перевода из сырых логитов в Морзе (а после и в текст) используется CTC beam decoder. Благодаря особенности работы он максимизирует правдоподобие всей последовательности, что в среднем лучше чем жадная декодировка.

Далее с помощью словаря Морзе -> Кириллица последовательность переводится в человекочитаемый текст. Символы, которые не получилось расшифровать, опускаются.

## Задача со звездочкой

К сожалению, я не успел решить задачу со звездочкой, потому что, пошел немного не в том направлении. Вместо того чтобы сосредоточиться на очевидном решении, я попытался подходить к задаче как к криптографической и пытался "взломать энигму".

Однако решение оказалось гораздо проще и элегантнее — достаточно было всего лишь инвертировать символы Морзе: поменять точки на тире, а тире на точки. Это действительно довольно очевидный шаг, который мне, к сожалению, не пришел в голову.

## Результат

Если закрывать глаза на фиаско с задачей со звездочкой, то модель получилась стабильная, с хорошей обобщающей способностью. Она показывает конкурентный результат и за сравнительно небольшое количество параметров (чуть меньше 800K) выдает достойный результат. 

Также ее можно использовать и за пределами кириллицы без дообучения, так как расшифровывается именно последовательность из точек и тире.